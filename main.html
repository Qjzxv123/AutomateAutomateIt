<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Automate It Production Planner</title>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
	<style>
		body {
			font-family: 'Roboto', Arial, sans-serif;
			background: #181c20;
			color: #f3f3f3;
			margin: 0;
			padding: 0;
		}
		header {
			background: #23272b;
			padding: 1.5rem 2rem;
			display: flex;
			align-items: center;
			justify-content: space-between;
			box-shadow: 0 2px 8px #000a;
		}
		.logo {
			font-size: 2rem;
			font-weight: 700;
			letter-spacing: 2px;
			color: #ffb347;
		}
		.planner-container {
			max-width: 1200px;
			margin: 2rem auto;
			background: #23272b;
			border-radius: 16px;
			box-shadow: 0 4px 24px #0006;
			padding: 2rem;
		}
		.input-section {
			display: flex;
			gap: 1rem;
			align-items: center;
			margin-bottom: 2rem;
		}
		.input-section select, .input-section input {
			padding: 0.5rem 1rem;
			border-radius: 8px;
			border: none;
			font-size: 1rem;
		}
		.input-section button {
			background: #ffb347;
			color: #23272b;
			border: none;
			border-radius: 8px;
			padding: 0.5rem 1.5rem;
			font-size: 1rem;
			font-weight: 700;
			cursor: pointer;
			transition: background 0.2s;
		}
		.input-section button:hover {
			background: #ffd580;
		}
		.production-plan {
			background: #1a1e22;
			border-radius: 12px;
			padding: 2rem;
			min-height: 300px;
			box-shadow: 0 2px 8px #0004;
		}
		.placeholder-graph {
			color: #888;
			text-align: center;
			margin-top: 4rem;
			font-size: 1.2rem;
		}
	</style>
</head>
<body>
	<header>
		<div class="logo">Automate It Planner</div>
		<div>Inspired by satisfactory-calculator.com</div>
	</header>
	<div class="planner-container">
		<div class="input-section">
			<!-- Custom select with icons. The real value is stored in the hidden input (#item-select) for compatibility -->
			<div id="item-select-container" style="position:relative;display:inline-block;">
				<input type="hidden" id="item-select" value="">
				<button type="button" id="item-select-toggle" style="background:#2b2f33;color:#fff;border:none;padding:0.4rem 0.6rem;border-radius:8px;display:inline-flex;align-items:center;gap:0.5rem;cursor:pointer;">
					<img id="item-select-icon" src="" alt="" style="width:24px;height:24px;display:none;object-fit:contain;border-radius:4px;">
					<span id="item-select-label">Select Item</span>
					<span style="margin-left:8px;font-size:0.9rem;opacity:0.8;">▾</span>
				</button>
				<div id="item-select-options" style="display:none;position:absolute;left:0;top:calc(100% + 6px);background:#23272b;border:1px solid #333;border-radius:8px;max-height:320px;overflow:auto;z-index:300;min-width:280px;padding:4px;box-shadow:0 6px 18px rgba(0,0,0,0.6);">
					<!-- options populated dynamically -->
				</div>
			</div>
			<input id="rate-input" type="number" min="0.1" step="0.1" placeholder="Rate per minute">
			<label for="optimize-select" style="margin-left:1rem;">Optimize by:</label>
			<select id="optimize-select">
				<option value="space">Space</option>
				<option value="power">Power</option>
				<option value="buildings">Buildings</option>
			</select>
				<button id="edit-available-items-btn" style="margin-left:1rem;">Set Available Items</button>

				<!-- Modal for available items -->
					<div id="available-items-modal" style="display:none;position:fixed;z-index:1000;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.5);align-items:center;justify-content:center;">
						<div style="background:#23272b;padding:2rem 2.5rem;border-radius:12px;min-width:720px;width:85vw;max-width:1200px;min-height:60vh;max-height:90vh;overflow:auto;display:flex;flex-direction:column;">
						<h2 style="margin-top:0;">Set Available Items</h2>
							<form id="available-items-form" style="display:flex;flex-direction:column;gap:1rem;flex:1 1 auto;">
							<table id="available-items-table" style="width:100%;margin-bottom:1rem;">
								<thead><tr><th>Item</th><th>Amount</th><th></th></tr></thead>
								<tbody></tbody>
							</table>
								<div style="display:flex;gap:0.75rem;flex-wrap:wrap;">
									<button type="button" id="add-available-item-row">Add New Item</button>
								</div>
								<div style="margin-top:auto;position:sticky;bottom:0;background:#23272b;padding-top:1rem;display:flex;align-items:center;justify-content:space-between;gap:0.75rem;">
									<div style="display:flex;gap:0.75rem;align-items:center;">
										<button type="button" id="open-level-presets-btn">Level Presets</button>
									</div>
									<div style="display:flex;gap:0.75rem;align-items:center;">
										<button type="button" id="close-available-items-modal">Cancel</button>
										<button type="submit">Save</button>
									</div>
								</div>
						</form>
					</div>
				</div>
					<!-- Level Presets Modal -->
					<div id="level-presets-modal" style="display:none;position:fixed;z-index:1200;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.55);align-items:center;justify-content:center;">
						<div style="background:#23272b;padding:1.75rem 2rem;border-radius:12px;min-width:520px;width:70vw;max-width:900px;max-height:85vh;display:flex;flex-direction:column;overflow:hidden;">
							<div style="display:flex;align-items:center;gap:1rem;">
								<h2 style="margin:0;flex:1;">Level Presets</h2>
								<button type="button" id="close-level-presets" style="background:#444;color:#fff;border:none;padding:0.4rem 0.8rem;border-radius:6px;cursor:pointer;">Close</button>
							</div>
							<div style="margin-top:0.75rem;">
								<input id="level-presets-search" type="text" placeholder="Search presets..." style="width:100%;padding:0.55rem 0.7rem;border:1px solid #333;border-radius:8px;background:#1f2327;color:#fff;">
							</div>
							<div id="level-presets-list" style="margin-top:1rem;overflow:auto;padding-right:4px;flex:1 1 auto;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:0.75rem;"></div>
							<div id="level-presets-empty" style="display:none;color:#888;text-align:center;margin-top:2rem;">No presets found.</div>
						</div>
					</div>
			<button id="calculate-btn">Calculate</button>
		</div>
		<div class="production-plan" id="production-plan">
			<div style="display: flex; flex-direction: column; gap: 1.5rem;">
				<div id="network-graph" style="width:100%;height:500px;background:#222;border-radius:8px;"></div>
				<div>
					<div class="placeholder-graph">
						Production plan will appear here as a tree/graph.<br>
						(Icons, rates, and buildings will be shown)
					</div>
					<div id="plan-tree-html"></div>
				</div>
			</div>
		</div>
		<!-- Vis Network CDN -->
		<script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
		<link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
		<script>
// Load external Items.json and Recipes.json, then initialize the UI using those datasets.
let items = {};    // map: id -> { name, icon, type }
let recipes = [];  // array: { machine, inputs:[], outputs:[] }

// Kick off async data load immediately
const itemsLoadedPromise = (async function loadData() {
	try {
		const [itemsRes, recipesRes] = await Promise.all([
			fetch('Items.json'),
			fetch('Recipes.json'),
		]);
		const itemsJson = await itemsRes.json();
		// Items.json is an array of objects with id/name/icon/type (and sometimes extra fields); build a map keyed by id
		const map = {};
		if (Array.isArray(itemsJson)) {
			for (const it of itemsJson) {
				if (!it || !it.id) continue;
				map[it.id] = {
					name: it.name || it.id,
					icon: it.icon || '',
					type: (it.type || '').toLowerCase(),
				};
			}
		}
		items = map;

		// Recipes.json is a flat array with fields: machine, input[], output[]
		const recipesJson = await recipesRes.json();
		const out = [];
		if (Array.isArray(recipesJson)) {
			for (const r of recipesJson) {
				if (!r || typeof r !== 'object') continue;
				const inputs = Array.isArray(r.input) ? r.input.map(x => ({ item: x.item, rate: x.rate }))
													  : (Array.isArray(r.inputs) ? r.inputs : []);
				const outputs = Array.isArray(r.output) ? r.output.map(x => ({ item: x.item, rate: x.rate }))
														: (Array.isArray(r.outputs) ? r.outputs : []);
				const buildingId = (r.building || r.machine || '').toString().trim();
				// Provide a simple display name fallback to avoid undefined usages elsewhere
				const displayName = outputs && outputs.length > 0 ? outputs.map(o => o.item).join(' + ') : (buildingId || 'Recipe');
				out.push({
					machine: r.machine,
					building: buildingId,
					name: displayName,
					inputs,
					outputs,
				});
			}
		}
		recipes = out;
	} catch (err) {
		console.error('Failed to load Items.json or Recipes.json:', err);
	}
})();

	const buildings = {
		press: { name: 'Press', power: 10, space: 10 },
		furnace: { name: 'Furnace', power: 10, space: 10 },
		cutter: { name: 'Cutter', power: 8, space: 2 },
		welder: { name: 'Welder', power: 15, space: 17 },
		advanced_furnace: { name: 'Advanced Furnace', power: 20, space: 76 },
		advanced_cutter: { name: 'Advanced Cutter', power: 15, space: 24 },
		advanced_press: { name: 'Advanced Press', power: 20, space: 23 },
		manufacturer: { name: 'Manufacturer', power: 15, space: 9 },
        bifluxor: { name: 'Bifluxor', power: 30, space: 48 },
		chemical_infuser: { name: 'Chemical Infuser', power: 45, space: 80 },
		storage_packing: { name: 'Storage Packing', power: 50, space: 100 },
		dissolution_chamber: { name: 'Dissolution Chamber', power: 25, space: 22 },
		distilation_column: { name: 'Distilation Column', power: 30, space: 22 },
		};
		// Populate custom item dropdown (icon + label). The real value is stored in the hidden input (#item-select)
		const itemSelect = document.getElementById('item-select'); // hidden input to preserve existing code
		const rateInput = document.getElementById('rate-input');
		const itemSelectOptions = document.getElementById('item-select-options');
		const itemSelectToggle = document.getElementById('item-select-toggle');
		const itemSelectLabel = document.getElementById('item-select-label');
		const itemSelectIcon = document.getElementById('item-select-icon');
		const itemSelectContainer = document.getElementById('item-select-container');

		// Build searchable options
		itemSelectOptions.innerHTML = '';
		const mainSearchWrap = document.createElement('div');
		mainSearchWrap.style.padding = '4px';
		const mainSearch = document.createElement('input');
		mainSearch.type = 'text';
		mainSearch.placeholder = 'Search items...';
		mainSearch.style.width = '100%';
		mainSearch.style.boxSizing = 'border-box';
		mainSearch.style.padding = '6px 8px';
		mainSearch.style.marginBottom = '4px';
		mainSearch.style.border = '1px solid #444';
		mainSearch.style.borderRadius = '6px';
		mainSearch.style.background = '#1f2327';
		mainSearch.style.color = '#fff';
		mainSearchWrap.appendChild(mainSearch);
		itemSelectOptions.appendChild(mainSearchWrap);

		const mainList = document.createElement('div');
		itemSelectOptions.appendChild(mainList);

		function renderMainOptions(filter = '') {
			const f = filter.trim().toLowerCase();
			mainList.innerHTML = '';
			Object.entries(items).forEach(([key, item]) => {
				const label = (item.name || key);
				if (f && !(label.toLowerCase().includes(f) || key.toLowerCase().includes(f))) return;
				const row = document.createElement('div');
				row.className = 'item-option';
				row.style.display = 'flex';
				row.style.alignItems = 'center';
				row.style.gap = '0.5rem';
				row.style.padding = '6px';
				row.style.borderRadius = '6px';
				row.style.cursor = 'pointer';
				row.dataset.key = key;

				const img = document.createElement('img');
				img.src = item.icon ? (item.icon) : '';
				img.alt = label;
				img.style.width = '28px';
				img.style.height = '28px';
				img.style.objectFit = 'contain';
				img.style.borderRadius = '4px';

				const span = document.createElement('span');
				span.textContent = label;
				span.style.flex = '1';

				row.appendChild(img);
				row.appendChild(span);

				row.addEventListener('click', () => {
					updateItemSelectDisplay(key);
					// Hide options
					itemSelectOptions.style.display = 'none';
				});

				// Hover effect
				row.addEventListener('mouseenter', () => { row.style.background = '#2b2f33'; });
				row.addEventListener('mouseleave', () => { row.style.background = 'transparent'; });

				mainList.appendChild(row);
			});
		}

		function updateItemSelectDisplay(itemKey, { fireChange = true } = {}) {
			const itemData = items[itemKey] || null;
			itemSelect.value = itemKey || '';
			if (itemData) {
				itemSelectLabel.textContent = itemData.name || itemKey;
				if (itemData.icon) {
					itemSelectIcon.src = itemData.icon;
					itemSelectIcon.style.display = 'inline-block';
				} else {
					itemSelectIcon.style.display = 'none';
				}
			} else {
				itemSelectLabel.textContent = 'Select Item';
				itemSelectIcon.style.display = 'none';
			}
			if (fireChange) {
				itemSelect.dispatchEvent(new Event('change'));
			}
		}

		function syncUrlState() {
			const params = new URLSearchParams(window.location.search);
			if (itemSelect.value) {
				params.set('item', itemSelect.value);
			} else {
				params.delete('item');
			}
			if (!rateInput.disabled && rateInput.value) {
				params.set('rate', rateInput.value);
			} else {
				params.delete('rate');
			}
			const query = params.toString();
			const hash = window.location.hash || '';
			const newUrl = query ? `${window.location.pathname}?${query}${hash}` : `${window.location.pathname}${hash}`;
			history.replaceState(null, '', newUrl);
		}

		function applyInitialStateFromUrl() {
			const params = new URLSearchParams(window.location.search);
			const itemParam = params.get('item');
			let shouldAutoCalculate = false;
			if (itemParam && items[itemParam]) {
				updateItemSelectDisplay(itemParam);
				shouldAutoCalculate = true;
			}
			const rateParam = params.get('rate');
			if (rateParam !== null && rateParam !== '') {
				const parsedRate = parseFloat(rateParam);
				if (!Number.isNaN(parsedRate)) {
					if (!rateInput.disabled) {
						rateInput.value = parsedRate;
					}
				}
			}
			syncUrlState();
			// Auto-run calculation if we have an item from URL and either a valid rate or it's a nonsolid (rate not needed)
			if (shouldAutoCalculate) {
				const selType = items[itemParam]?.type;
				if (selType === 'nonsolid' || rateInput.value) {
					const calcBtn = document.getElementById('calculate-btn');
					if (calcBtn) {
						// Delay a tick to ensure any UI state (e.g., disabled rate field) has settled
						setTimeout(() => calcBtn.click(), 0);
					}
				}
			}
		}

		// Initial render after data is ready
		itemsLoadedPromise.then(() => {
			renderMainOptions('');
			applyInitialStateFromUrl();
		});

		// Search filter
		mainSearch.addEventListener('input', () => {
			renderMainOptions(mainSearch.value);
		});

		// Toggle dropdown visibility
		itemSelectToggle.addEventListener('click', (e) => {
			e.stopPropagation();
			itemSelectOptions.style.display = itemSelectOptions.style.display === 'block' ? 'none' : 'block';
			if (itemSelectOptions.style.display === 'block') {
				// Focus search for quick filtering
				const inp = itemSelectOptions.querySelector('input[type="text"]');
				if (inp) setTimeout(() => inp.focus(), 0);
			}
		});

		// Close dropdown when clicking outside
		document.addEventListener('click', (e) => {
			if (!itemSelectContainer.contains(e.target)) {
				itemSelectOptions.style.display = 'none';
			}
		});

				// Modal logic for available items
						let availableItemsList = [];
						// Load from localStorage if present
						try {
							const saved = localStorage.getItem('availableItemsList');
							if (saved) {
								availableItemsList = JSON.parse(saved);
							}
						} catch(e) {}
				const modal = document.getElementById('available-items-modal');
				const openModalBtn = document.getElementById('edit-available-items-btn');
				const closeModalBtn = document.getElementById('close-available-items-modal');
				const addRowBtn = document.getElementById('add-available-item-row');
						const openLevelPresetsBtn = document.getElementById('open-level-presets-btn');
				const tableBody = document.querySelector('#available-items-table tbody');
				const form = document.getElementById('available-items-form');
						// Level presets modal elements
						const levelPresetsModal = document.getElementById('level-presets-modal');
						const closeLevelPresetsBtn = document.getElementById('close-level-presets');
						const levelPresetsSearch = document.getElementById('level-presets-search');
						const levelPresetsList = document.getElementById('level-presets-list');
						const levelPresetsEmpty = document.getElementById('level-presets-empty');

						let levelPresets = [];
						const levelPresetsLoadedPromise = fetch('LevelPresets.json')
							.then(r => r.json())
							.then(json => { if (Array.isArray(json)) levelPresets = json; })
							.catch(() => { levelPresets = []; });

						function renderLevelPresets(filter = '') {
							const f = filter.trim().toLowerCase();
							levelPresetsList.innerHTML = '';
							let shown = 0;
							for (const preset of levelPresets) {
								if (!preset || !preset.name) continue;
								if (f && !preset.name.toLowerCase().includes(f)) continue;
								shown++;
								const card = document.createElement('div');
								card.style.background = '#2b2f33';
								card.style.border = '1px solid #333';
								card.style.borderRadius = '10px';
								card.style.padding = '0.65rem 0.75rem';
								card.style.display = 'flex';
								card.style.flexDirection = 'column';
								card.style.gap = '0.4rem';
								card.style.cursor = 'pointer';
								card.style.transition = 'background .15s';
								card.innerHTML = `
									<div style="font-weight:600;font-size:0.95rem;">${preset.name}</div>
									<div style="font-size:0.72rem;line-height:1.2;color:#bbb;max-height:4.2em;overflow:hidden;">${(preset.items||[]).map(i=>i.item + (i.rate?`(${i.rate})`:'')).join(', ')}</div>
								`;
								card.addEventListener('mouseenter', ()=> card.style.background = '#34393e');
								card.addEventListener('mouseleave', ()=> card.style.background = '#2b2f33');
								card.addEventListener('click', () => {
									applyLevelPreset(preset);
								});
								levelPresetsList.appendChild(card);
							}
							levelPresetsEmpty.style.display = shown === 0 ? 'block' : 'none';
						}

						function applyLevelPreset(preset) {
							if (!preset || !Array.isArray(preset.items)) return;
							// Build new availableItemsList from preset
							const built = [];
							for (const ent of preset.items) {
								if (!ent || !ent.item) continue;
								const id = ent.item;
								if (!items[id]) continue; // skip unknown
								const type = items[id].type;
								if (type === 'nonsolid' || typeof ent.rate === 'undefined') {
									built.push({ item: id });
								} else {
									built.push({ item: id, amount: ent.rate });
								}
							}
							availableItemsList = built;
							// Persist immediately (respect nonsolid rule)
							try {
								const filtered = availableItemsList.map(row => {
									const type = items[row.item]?.type;
									return type === 'nonsolid' ? { item: row.item } : row;
								});
								localStorage.setItem('availableItemsList', JSON.stringify(filtered));
							} catch(e) {}
							renderAvailableItemsTable();
							levelPresetsModal.style.display = 'none';
						}

						openLevelPresetsBtn.addEventListener('click', async () => {
							await levelPresetsLoadedPromise;
							renderLevelPresets('');
							levelPresetsModal.style.display = 'flex';
							levelPresetsSearch.value = '';
							setTimeout(()=> levelPresetsSearch.focus(), 0);
						});
						closeLevelPresetsBtn.addEventListener('click', () => {
							levelPresetsModal.style.display = 'none';
						});
						levelPresetsSearch.addEventListener('input', () => {
							renderLevelPresets(levelPresetsSearch.value);
						});
						// Close presets modal when clicking outside inner panel
						levelPresetsModal.addEventListener('click', (e) => {
							if (e.target === levelPresetsModal) levelPresetsModal.style.display = 'none';
						});

				function renderAvailableItemsTable() {
					// Combine duplicate items (solids only, sum amounts)
					const combined = [];
					for (const row of availableItemsList) {
						const type = items[row.item]?.type;
						if (type === 'nonsolid') {
							if (!combined.some(r => r.item === row.item)) {
								combined.push({ item: row.item });
							}
						} else {
							const existing = combined.find(r => r.item === row.item);
							if (existing) {
								existing.amount = (existing.amount || 0) + (row.amount || 0);
							} else {
								combined.push({ item: row.item, amount: row.amount });
							}
						}
					}
					// Replace availableItemsList with combined
					availableItemsList = combined;
					tableBody.innerHTML = '';
					availableItemsList.forEach((row, idx) => {
						const type = items[row.item]?.type;
						const selectedItem = items[row.item];
						const tr = document.createElement('tr');
						tr.innerHTML = `
							<td>
								<div class="avail-item-select-container" style="position:relative;display:inline-block;">
									<input type="hidden" class="avail-item-select" value="${row.item ?? ''}">
									<button type="button" class="avail-item-toggle" style="background:#2b2f33;color:#fff;border:none;padding:0.3rem 0.5rem;border-radius:8px;display:inline-flex;align-items:center;gap:0.5rem;cursor:pointer;">
										<img class="avail-item-icon" src="${selectedItem?.icon ? selectedItem.icon : ''}" alt="" style="width:22px;height:22px;${selectedItem?.icon ? '' : 'display:none;'}object-fit:contain;border-radius:4px;">
										<span class="avail-item-label">${selectedItem?.name || 'Select Item'}</span>
										<span style="margin-left:8px;font-size:0.85rem;opacity:0.8;">▾</span>
									</button>
									<div class="avail-item-options" style="display:none;position:absolute;left:0;top:calc(100% + 6px);background:#23272b;border:1px solid #333;border-radius:8px;max-height:260px;overflow:auto;z-index:1000;min-width:260px;padding:4px;box-shadow:0 6px 18px rgba(0,0,0,0.6);"></div>
								</div>
							</td>
							<td>${type === 'nonsolid' ? '<span style="color:#888;">N/A</span>' : `<input type=\"number\" min=\"0\" step=\"1\" value=\"${row.amount ?? ''}\" style=\"width:80px;\">`}</td>
							<td><button type="button" data-row="${idx}" class="remove-available-item-row">Remove</button></td>
						`;
						tableBody.appendChild(tr);

						// Wire up custom dropdown for this row
						const container = tr.querySelector('.avail-item-select-container');
						const hiddenInput = container.querySelector('.avail-item-select');
						const toggleBtn = container.querySelector('.avail-item-toggle');
						const labelEl = container.querySelector('.avail-item-label');
						const iconEl = container.querySelector('.avail-item-icon');
						const optionsEl = container.querySelector('.avail-item-options');

						// Build options list with search
						optionsEl.innerHTML = '';
						const searchWrap = document.createElement('div');
						searchWrap.style.padding = '4px';
						const searchInput = document.createElement('input');
						searchInput.type = 'text';
						searchInput.placeholder = 'Search items...';
						searchInput.style.width = '100%';
						searchInput.style.boxSizing = 'border-box';
						searchInput.style.padding = '6px 8px';
						searchInput.style.marginBottom = '4px';
						searchInput.style.border = '1px solid #444';
						searchInput.style.borderRadius = '6px';
						searchInput.style.background = '#1f2327';
						searchInput.style.color = '#fff';
						searchWrap.appendChild(searchInput);
						optionsEl.appendChild(searchWrap);

						const list = document.createElement('div');
						optionsEl.appendChild(list);

						function renderOpts(filter = '') {
							const f = filter.trim().toLowerCase();
							list.innerHTML = '';
							Object.entries(items).forEach(([k, it]) => {
								const label = (it.name || k);
								if (f && !(label.toLowerCase().includes(f) || k.toLowerCase().includes(f))) return;
								const optRow = document.createElement('div');
								optRow.style.display = 'flex';
								optRow.style.alignItems = 'center';
								optRow.style.gap = '0.5rem';
								optRow.style.padding = '6px';
								optRow.style.borderRadius = '6px';
								optRow.style.cursor = 'pointer';
								optRow.dataset.key = k;
								const oimg = document.createElement('img');
								oimg.src = it.icon ? (it.icon) : '';
								oimg.alt = label;
								oimg.style.width = '24px';
								oimg.style.height = '24px';
								oimg.style.objectFit = 'contain';
								oimg.style.borderRadius = '4px';
								const ospan = document.createElement('span');
								ospan.textContent = label;
								ospan.style.flex = '1';
								optRow.appendChild(oimg);
								optRow.appendChild(ospan);
								optRow.addEventListener('mouseenter', () => { optRow.style.background = '#2b2f33'; });
								optRow.addEventListener('mouseleave', () => { optRow.style.background = 'transparent'; });
								optRow.addEventListener('click', (ev) => {
									ev.stopPropagation();
									availableItemsList[idx].item = k;
									if (items[k]?.type === 'nonsolid') {
										availableItemsList[idx].amount = null;
									}
									// Re-render to reflect new selection and amount cell
									renderAvailableItemsTable();
								});
								list.appendChild(optRow);
							});
						}

						renderOpts('');
						searchInput.addEventListener('input', () => renderOpts(searchInput.value));

						// Toggle behavior
						toggleBtn.addEventListener('click', (ev) => {
							ev.stopPropagation();
							// Close other open dropdowns in the table
							Array.from(tableBody.querySelectorAll('.avail-item-options')).forEach(el => { if (el !== optionsEl) el.style.display = 'none'; });
							optionsEl.style.display = optionsEl.style.display === 'block' ? 'none' : 'block';
						});
					});

					// One-time document click to close any open modal dropdowns
					if (!window.__availDropdownCloserBound) {
						window.__availDropdownCloserBound = true;
						document.addEventListener('click', (e) => {
							const modalEl = document.getElementById('available-items-modal');
							if (!modalEl.contains(e.target)) return;
							const insideDropdown = e.target.closest && (e.target.closest('.avail-item-options') || e.target.closest('.avail-item-toggle'));
							if (insideDropdown) return;
							Array.from(document.querySelectorAll('#available-items-table .avail-item-options')).forEach(el => el.style.display = 'none');
						});
					}
				}

						openModalBtn.addEventListener('click', () => {
							if (availableItemsList.length === 0) {
								availableItemsList.push({ item: Object.keys(items)[0], amount: 1 });
							}
							renderAvailableItemsTable();
							modal.style.display = 'flex';
						});
				closeModalBtn.addEventListener('click', () => {
					modal.style.display = 'none';
				});
				addRowBtn.addEventListener('click', () => {
					// Add a new row with no item selected (forces 'Select item' in the dropdown)
					availableItemsList.push({ item: '', amount: 1 });
					renderAvailableItemsTable();
				});
				tableBody.addEventListener('click', (e) => {
					if (e.target.classList.contains('remove-available-item-row')) {
						const idx = parseInt(e.target.getAttribute('data-row'));
						availableItemsList.splice(idx, 1);
						renderAvailableItemsTable();
					}
				});
				tableBody.addEventListener('input', (e) => {
					const tr = e.target.closest('tr');
					const idx = Array.from(tableBody.children).indexOf(tr);
					if (e.target.tagName === 'INPUT') {
						// Only allow input for solids
						if (items[availableItemsList[idx].item]?.type !== 'nonsolid') {
							availableItemsList[idx].amount = parseInt(e.target.value) || 0;
						}
					}
				});
						form.addEventListener('submit', (e) => {
							e.preventDefault();
					// Save to localStorage, but remove amount for nonsolids
							try {
								const filtered = availableItemsList.map(row => {
									const type = items[row.item]?.type;
							return type === 'nonsolid' ? { item: row.item } : row;
								});
								localStorage.setItem('availableItemsList', JSON.stringify(filtered));
							} catch(e) {}
							modal.style.display = 'none';
						});

		// Disable rate input for nonsolid
		itemSelect.addEventListener('change', function() {
			const selectedType = items[this.value]?.type;
			if (selectedType === 'nonsolid') {
				rateInput.value = '';
				rateInput.disabled = true;
				rateInput.placeholder = 'No rate needed';
			} else {
				rateInput.disabled = false;
				rateInput.placeholder = 'Rate per minute';
			}
			syncUrlState();
		});
		rateInput.addEventListener('input', () => {
			syncUrlState();
		});


		// --- Basic calculation and display logic ---
		document.getElementById('calculate-btn').addEventListener('click', async () => {
			// Ensure external data is loaded
			await itemsLoadedPromise;
			const selectedItem = itemSelect.value;
			const selectedType = items[selectedItem]?.type;
			let rate = 1;
			if (selectedType !== 'nonsolid') {
				rate = parseFloat(rateInput.value);
			}
			const planDiv = document.getElementById('production-plan');
			const optimizeBy = document.getElementById('optimize-select').value;
			// Get available items and amounts from modal
			const availableItems = availableItemsList.map(row => row.item);
			const availableAmounts = {};
			availableItemsList.forEach(row => { availableAmounts[row.item] = row.amount; });
			if (!selectedItem || (selectedType !== 'nonsolid' && (isNaN(rate) || rate <= 0))) {
				planDiv.innerHTML = '<div class="placeholder-graph">Please select an item and enter a valid rate.</div>';
				return;
			}
			// For nonsolid, set rate to 1 (arbitrary, since rate is not needed)
			if (selectedType === 'nonsolid') {
				rate = 1;
			}

			// Helper: get all recipes for an item
			function getRecipesForItem(itemKey) {
				return recipes.filter(r => r.outputs.some(o => o.item === itemKey));
			}


			// Helper: combinatorial optimizer for recipe splitting
			// Integer building counts, pool excess for reuse
			// Brute-force optimizer: test all combinations of normal/overclocked for all recipes, select lowest metric
			function optimizeRecipes(itemKey, requiredRate, excessPool = {}) {
				const all = getRecipesForItem(itemKey);
				if (all.length === 0) return null;
				// Use excess if available
				let needed = requiredRate;
				if (excessPool[itemKey]) {
					if (excessPool[itemKey] >= needed) {
						excessPool[itemKey] -= needed;
						return [];
					} else {
						needed -= excessPool[itemKey];
						excessPool[itemKey] = 0;
					}
				}
				// Build all recipe variants (normal/overclocked)
				let variants = [];
				for (const r of all) {
					const output = r.outputs.find(o => o.item === itemKey);
					const outRate = output && output.rate ? output.rate : 1;
					// Check if all outputs are nonsolid
					const onlyNonsolid = r.outputs.every(o => {
						const t = items[o.item]?.type;
						return t === 'nonsolid';
					});
					variants.push({ recipe: r, outRate, overclocked: false });
					// Prevent overclocking if not enough available items for any input
					let canOverclock = true;
					if (!onlyNonsolid) {
						if (typeof availableAmounts !== 'undefined') {
							for (const input of r.inputs) {
								const inputType = items[input.item]?.type;
								if (inputType !== 'nonsolid' && typeof availableAmounts[input.item] === 'number') {
									// Overclocked input rate is doubled
									const required = (input.rate ?? 1) * 2;
									if (availableAmounts[input.item] < required) {
										canOverclock = false;
										break;
									}
								}
							}
						}
						if (canOverclock) {
							variants.push({ recipe: r, outRate: outRate * 2, overclocked: true });
						}
					}
				}
				// Try all combinations of building counts for each variant (integer, sum >= needed)
				// For N variants, try all combinations of building counts up to a reasonable max
				const maxBuildings = 8; // limit for performance
				let bestPlan = null;
				let bestValue = Infinity;
				let comboCount = 0;
				function* combos(n, total) {
					if (n === 1) {
						yield [total];
						return;
					}
					for (let i = 0; i <= total; ++i) {
						for (const rest of combos(n - 1, total - i)) {
							yield [i, ...rest];
						}
					}
				}
				// Try all combinations of building counts (up to maxBuildings)
				for (let totalBuildings = 1; totalBuildings <= maxBuildings; ++totalBuildings) {
					for (const counts of combos(variants.length, totalBuildings)) {
						comboCount++;
						let produced = 0;
						let plan = [];
						let totalPower = 0, totalSpace = 0, totalBld = 0;
						for (let i = 0; i < variants.length; ++i) {
							if (counts[i] === 0) continue;
							const v = variants[i];
							produced += v.outRate * counts[i];
							const building = buildings[v.recipe.building];
							let space = building.space * counts[i];
							plan.push({ recipe: v.recipe, amount: v.outRate * counts[i], used: 0, overclocked: v.overclocked, buildingCount: counts[i] });
							totalSpace += space;
							totalBld += counts[i];
						}
						if (produced < needed) continue;
						// Assign 'used' for each plan entry
						let remaining = needed;
						for (let p of plan) {
							if (remaining > 0) {
								const use = Math.min(p.amount, remaining);
								p.used = use;
								remaining -= use;
							} else {
								p.used = 0;
							}
						}
						// Compute power based on only the used portion of each building
						for (let p of plan) {
							if (p.used > 0) {
								const building = buildings[p.recipe.building];
								let buildingPower = building.power;
								if (p.overclocked) buildingPower *= 2.5;
								let fraction = p.used / p.amount;
								totalPower += buildingPower * p.buildingCount * fraction;
							}
						}
						// Compute value for metric
						let value = 0;
						if (optimizeBy === 'space') value = totalSpace;
						else if (optimizeBy === 'power') value = totalPower;
						else if (optimizeBy === 'buildings') value = totalBld;

						// Tie-breaking rules (in order):
						// 1) Lower metric value wins
						// 2) If equal, fewer total buildings wins
						// 3) If still equal, fewer overclocked buildings wins (prefer normal operation when possible)
						const candidateBuildings = totalBld;
						const bestBuildings = bestPlan ? bestPlan.reduce((s, p) => s + p.buildingCount, 0) : Infinity;
						const candidateOverclocked = plan.reduce((s, p) => s + (p.overclocked ? p.buildingCount : 0), 0);
						const bestOverclocked = bestPlan ? bestPlan.reduce((s, p) => s + (p.overclocked ? p.buildingCount : 0), 0) : Infinity;

						const isBetter = (
							value < bestValue ||
							(value === bestValue && (
								candidateBuildings < bestBuildings ||
								(candidateBuildings === bestBuildings && candidateOverclocked < bestOverclocked)
							))
						);
						if (isBetter) {
							bestValue = value;
							bestPlan = plan.map(p => ({ ...p }));
						}
					}
				}
				// Pool excess
				if (bestPlan) {
					let produced = bestPlan.reduce((sum, p) => sum + p.amount, 0);
					if (produced > needed) {
						excessPool[itemKey] = (excessPool[itemKey] || 0) + (produced - needed);
					}
					return bestPlan;
				}
				return null;
			}

			// Recursive function to build input tree
			function buildInputTree(itemKey, requiredRate, depth = 0, totals = { power: 0, space: 0, buildings: 0 }, producedNonsolids = {}, excessPool = {}, requirements = {}, fullRequirements = {}) {
				const item = items[itemKey];
				if (!item) {
					console.log(`Unknown item: ${itemKey}`);
					return `<li style='color:#f55;'>Unknown item: <b>${itemKey}</b></li>`;
				}
				const plans = optimizeRecipes(itemKey, requiredRate, excessPool);
				if (!plans) {
					// Only fail if not available and not producible (no recipe)
					if (availableItems.length && !availableItems.includes(itemKey) && getRecipesForItem(itemKey).length === 0) {
						console.log(`Cannot make ${item.name}: not in available items and no recipe.`);
						return `<li style='color:#f55;'>${requiredRate ? requiredRate.toFixed(2) + ' ' : ''}<b>${item.name}</b> (not available and no recipe)</li>`;
					}
					if (typeof availableAmounts[itemKey] !== 'undefined' && requiredRate > availableAmounts[itemKey]) {
						console.log(`Cannot make ${item.name}: need ${requiredRate}, have ${availableAmounts[itemKey]}`);
						return `<li style='color:#f55;'>${requiredRate.toFixed(2)} <b>${item.name}</b> (need ${requiredRate}, have ${availableAmounts[itemKey]})</li>`;
					}
					return `<li>${requiredRate ? requiredRate.toFixed(2) + ' ' : ''}<b>${item.name}</b>${depth === 0 ? ' per minute' : ''}</li>`;
				}
				let html = `<li>`;
				html += `${requiredRate ? requiredRate.toFixed(2) + ' ' : ''}<b>${item.name}</b>${depth === 0 ? ' per minute' : ''}`;
				html += `<ul style=\"margin:0.5rem 0 0 1.5rem;\">`;
				   plans.forEach((plan, i) => {
					   const recipe = plan.recipe;
					   const amount = plan.amount;
					   const used = plan.used;
					   const output = recipe.outputs.find(o => o.item === itemKey);
					   let outRate = output && output.rate ? output.rate : 1;
					   let building = buildings[recipe.building];
					   // Overclocking: handled by optimizer, so plan.overclocked is set if used
					   let isOverclocked = plan.overclocked || false;
					   if (isOverclocked) outRate *= 2;
					   const buildingCount = amount && outRate ? (amount / outRate) : 1;
					   let totalPower = building ? building.power * buildingCount : 0;
					   if (isOverclocked && building) totalPower *= 2.5;
					   const totalSpace = building ? building.space * buildingCount : 0;
					   if (building) {
						   totals.power += totalPower;
						   totals.space += totalSpace;
						   totals.buildings += buildingCount;
					   }
					   html += `<li><b>${buildingCount}</b> x <span>${building ? building.name : 'Unknown Building'}</span> &mdash; <span>Power: <b>${totalPower.toFixed(2)}</b></span>, <span>Space: <b>${totalSpace.toFixed(2)}</b></span> <span style='color:#aaa'>(via ${recipe.name}${plans.length > 1 ? `, ${used.toFixed(2)}/min` : ''}${amount > used ? `, ${amount.toFixed(2)}/min produced` : ''}${isOverclocked ? ', Overclocked' : ''})</span></li>`;
					   recipe.inputs.forEach(input => {
						   const inputType = items[input.item]?.type;
						   const inputHasRecipe = getRecipesForItem(input.item).length > 0;
						   let inputRate = (input.rate ?? 0) * buildingCount;
						   if (isOverclocked) inputRate *= 2;
						   // Always accumulate into full BOM (including intermediates)
						   fullRequirements[input.item] = (fullRequirements[input.item] || 0) + inputRate;
						   if (inputType === 'nonsolid') {
							   if (!producedNonsolids[input.item]) {
								   producedNonsolids[input.item] = true;
								   if (inputHasRecipe) {
									   html += buildInputTree(input.item, inputRate, depth + 1, totals, producedNonsolids, excessPool, requirements, fullRequirements);
								   } else {
									   html += `<li><b>${items[input.item].name}</b></li>`;
									   // Nonsolids without a recipe are externally supplied
									   requirements[input.item] = (requirements[input.item] || 0) + inputRate;
								   }
							   } else {
								   html += `<li><b>${items[input.item].name}</b> (already produced)</li>`;
							   }
						   } else if (inputHasRecipe) {
							   html += buildInputTree(input.item, inputRate, depth + 1, totals, producedNonsolids, excessPool, requirements, fullRequirements);
						   } else {
							   html += `<li>${inputRate.toFixed(2)} <b>${items[input.item].name}</b>${depth === 0 ? ' per minute' : ''}</li>`;
							   // Base item with no recipe: add to requirements
							   requirements[input.item] = (requirements[input.item] || 0) + inputRate;
						   }
					   });
				   });
				html += `</ul></li>`;
				return html;
			}


			// Show the full production tree for the selected item and totals
			function renderTreeAutoOverclock() {
				const totals = { power: 0, space: 0, buildings: 0 };
				const requirements = {};
				const fullRequirements = {};
				const treeHtml = buildInputTree(selectedItem, rate, 0, totals, {}, {}, requirements, fullRequirements);
				// Build a sorted Bill of Materials (base requirements)
				const reqEntries = Object.entries(requirements);
				reqEntries.sort((a, b) => items[a[0]].name.localeCompare(items[b[0]].name));
				const reqListHtml = reqEntries.length
					? `<ul style="margin:0.5rem 0 0 1.5rem;">${reqEntries.map(([key, val]) => `<li>${val.toFixed(2)} <b>${items[key]?.name || key}</b> per minute</li>`).join('')}</ul>`
					: '<div style="color:#888;">No external items required.</div>';
				// Build full Bill of Materials (including intermediates)
				const fullReqEntries = Object.entries(fullRequirements);
				fullReqEntries.sort((a, b) => items[a[0]].name.localeCompare(items[b[0]].name));
				const fullReqListHtml = fullReqEntries.length
					? `<ul style=\"margin:0.5rem 0 0 1.5rem;\">${fullReqEntries.map(([key, val]) => `<li>${val.toFixed(2)} <b>${items[key]?.name || key}</b> per minute</li>`).join('')}</ul>`
					: '<div style=\"color:#888;\">No inputs required.</div>';
				let planTreeEl = document.getElementById('plan-tree-html');
				if (!planTreeEl) {
					const planContainer = document.getElementById('production-plan');
					if (planContainer) {
						planTreeEl = document.createElement('div');
						planTreeEl.id = 'plan-tree-html';
						planContainer.appendChild(planTreeEl);
					} else {
						return; // Nowhere to render
					}
				}
				planTreeEl.innerHTML = `
					<div style="font-size:1.3rem;margin-bottom:1rem;">
						<b>${rate}</b> <span>${items[selectedItem].name}</span> per minute
					</div>
					<div style="margin-bottom:1rem;font-size:1.1rem;">
						Total Power: <b>${totals.power.toFixed(2)}</b> &nbsp; | &nbsp; Total Space: <b>${totals.space.toFixed(2)}</b> &nbsp; | &nbsp; Total Buildings: <b>${totals.buildings.toFixed(2)}</b>
					</div>
					<div style="margin-bottom:0.5rem;font-size:1.1rem;">
						<b>Required items per minute</b>
					<div style=\"margin-top:1rem;margin-bottom:0.5rem;font-size:1.1rem;\">\n                        <b>Full bill of materials (incl. intermediates)</b>\n                    </div>
					${fullReqListHtml}
					</div>
					${reqListHtml}
					<ul style="margin:0.5rem 0 0 1.5rem;">${treeHtml}</ul>
				`;
			}
			renderTreeAutoOverclock();

			// --- Network Graph Visualization ---
			function buildGraphData(itemKey, requiredRate, nodes = [], edges = [], parentId = null, nodeMap = {}, depth = 0, producedNonsolids = {}, edgeLabels = {}, edgeIndex = {}) {
				const item = items[itemKey];
				const plans = optimizeRecipes(itemKey, requiredRate);
				// Use a composite key to merge like items at the same depth
				const nodeId = itemKey + '_' + depth;
				if (!nodeMap[nodeId]) {
					let nodeObj;
					let showRate = item.type !== 'nonsolid';
					if (item.icon) {
						nodeObj = {
							id: nodeId,
							label: showRate ? `${item.name}\n${requiredRate ? requiredRate.toFixed(2) : ''}${depth === 0 ? ' /min' : ''}` : `${item.name}`,
							shape: 'image',
							image: item.icon,
							color: '#ffb347',
							font: { color: '#fff', size: 18, multi: true },
							rate: requiredRate, count: 1, parents: new Set()
						};
					} else {
						nodeObj = {
							id: nodeId,
							label: showRate ? `${item.name}\n${requiredRate ? requiredRate.toFixed(2) : ''}${depth === 0 ? ' /min' : ''}` : `${item.name}`,
							shape: 'box',
							color: '#ffb347',
							font: { color: '#fff', size: 18, multi: true },
							rate: requiredRate, count: 1, parents: new Set()
						};
					}
					nodeMap[nodeId] = nodeObj;
					nodes.push(nodeObj);
				} else {
					nodeMap[nodeId].rate += requiredRate;
					nodeMap[nodeId].count += 1;
					let showRate = item.type !== 'nonsolid';
					nodeMap[nodeId].label = showRate ? `${item.name}\n${nodeMap[nodeId].rate.toFixed(2)}${depth === 0 ? ' /min' : ''}` : `${item.name}`;
				}
				// Note: intentionally do not add an edge from current node to parent here.
				// All edges are drawn from input (child) -> current node to avoid bidirectional/circular arrows.
				if (!plans) return { nodes, edges };
				plans.forEach((plan, i) => {
					const recipe = plan.recipe;
					const amount = plan.amount;
					const output = recipe.outputs.find(o => o.item === itemKey);
					let outRate = output && output.rate ? output.rate : 1;
					const buildingCount = amount && outRate ? (amount / outRate) : 1;
					recipe.inputs.forEach(input => {
						const inputType = items[input.item]?.type;
						const inputHasRecipe = getRecipesForItem(input.item).length > 0;
						const inputRate = (input.rate ?? 0) * buildingCount;
						const childId = input.item + '_' + (depth + 1);
						if (!nodeMap[childId]) {
							const inputItemObj = items[input.item];
							if (!inputItemObj) {
								console.log(`Unknown item in graph: ${input.item}`);
								nodeMap[childId] = { id: childId, label: `Unknown: ${input.item}\n${inputRate ? inputRate.toFixed(2) : ''}`, shape: 'ellipse', color: '#f55', font: { color: '#23272b', size: 16 }, rate: inputRate, count: 1, parents: new Set() };
								nodes.push(nodeMap[childId]);
							} else {
								let nodeObj;
								let showRate = inputItemObj.type !== 'nonsolid';
								if (inputItemObj.icon) {
									nodeObj = {
										id: childId,
										label: showRate ? `${inputItemObj.name}\n${inputRate ? inputRate.toFixed(2) : ''}${depth === 0 ? ' /min' : ''}` : `${inputItemObj.name}`,
										shape: 'image',
										image: inputItemObj.icon,
										color: inputType === 'nonsolid' ? '#4fc3f7' : '#fff',
										font: { color: '#fff', size: 16, multi: true },
										rate: inputRate, count: 1, parents: new Set()
									};
								} else {
									nodeObj = {
										id: childId,
										label: showRate ? `${inputItemObj.name}\n${inputRate ? inputRate.toFixed(2) : ''}${depth === 0 ? ' /min' : ''}` : `${inputItemObj.name}`,
										shape: 'ellipse',
										color: inputType === 'nonsolid' ? '#4fc3f7' : '#fff',
										font: { color: '#23272b', size: 16, multi: true },
										rate: inputRate, count: 1, parents: new Set()
									};
								}
								nodeMap[childId] = nodeObj;
								nodes.push(nodeObj);
							}
						} else {
							nodeMap[childId].rate += inputRate;
							nodeMap[childId].count += 1;
							// Update label to show combined rate, but hide for nonsolid
							let labelName = nodeMap[childId].label.split('\n')[0];
							let showRate = items[input.item]?.type !== 'nonsolid';
							nodeMap[childId].label = showRate ? `${labelName}\n${nodeMap[childId].rate.toFixed(2)}${depth === 0 ? ' /min' : ''}` : `${labelName}`;
						}
						// Label edges with building used; combine labels if multiple
						const buildingName = buildings[recipe.building]?.name || recipe.building;
						const edgeKey = childId + '->' + nodeId;
						if (!edgeLabels[edgeKey]) edgeLabels[edgeKey] = new Set();
						edgeLabels[edgeKey].add(buildingName);
						// Only add unique edges; otherwise update the label
						if (!nodeMap[childId].parents.has(nodeId)) {
							const labelText = Array.from(edgeLabels[edgeKey]).join(', ');
							edges.push({ from: childId, to: nodeId, arrows: 'to', color: '#aaa', width: 1.5, label: labelText, font: { color: '#ffb347', size: 12, strokeWidth: 0 } });
							edgeIndex[edgeKey] = edges.length - 1;
							nodeMap[childId].parents.add(nodeId);
						} else {
							const idx = edgeIndex[edgeKey];
							if (typeof idx === 'number' && edges[idx]) {
								edges[idx].label = Array.from(edgeLabels[edgeKey]).join(', ');
							}
						}
						if (inputType === 'nonsolid') {
							if (!producedNonsolids[input.item]) {
								producedNonsolids[input.item] = true;
								if (inputHasRecipe) {
									buildGraphData(input.item, inputRate, nodes, edges, childId, nodeMap, depth + 1, producedNonsolids, edgeLabels, edgeIndex);
								}
							}
						} else if (inputHasRecipe) {
							buildGraphData(input.item, inputRate, nodes, edges, childId, nodeMap, depth + 1, producedNonsolids, edgeLabels, edgeIndex);
						}
					});
				});
				return { nodes, edges };
			}

			// Render the network graph
			const graphDiv = document.getElementById('network-graph');
			if (graphDiv) {
				graphDiv.innerHTML = '';
				const data = buildGraphData(selectedItem, rate, [], [], null, {}, 0, {}, {}, {});
				if (data && data.nodes.length > 0) {
					// Remove .parents property from nodes for vis-network
					data.nodes.forEach(n => { if (n.parents) delete n.parents; });
					const network = new vis.Network(graphDiv, data, {
						nodes: {
							borderWidth: 2,
							shadow: true,
							shape: 'box',
							color: { background: '#ffb347', border: '#23272b', highlight: { background: '#ffd580', border: '#23272b' } },
							font: { color: '#23272b', size: 18, face: 'Roboto' },
							margin: 12
						},
						edges: {
							color: { color: '#aaa', highlight: '#ffb347', hover: '#ffb347' },
							arrows: 'to',
							smooth: { type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.3 },
							width: 1.5
						},
						layout: {
							hierarchical: {
								direction: 'UD',
								sortMethod: 'directed',
								nodeSpacing: 220,
								levelSeparation: 200,
								treeSpacing: 320,
								parentCentralization: true
							}
						},
						physics: false,
						interaction: {
							hover: true,
							tooltipDelay: 100,
							navigationButtons: true,
							keyboard: true
						}
					});

					// Highlight connected nodes on select
					network.on('selectNode', function(params) {
						const selected = params.nodes[0];
						const connectedNodes = network.getConnectedNodes(selected);
						network.selectNodes([selected, ...connectedNodes]);
						// Optionally, highlight edges too
						const connectedEdges = network.getConnectedEdges(selected);
						network.setSelection({ nodes: [selected, ...connectedNodes], edges: connectedEdges });
					});
					network.on('deselectNode', function() {
						network.unselectAll();
					});
				} else {
					graphDiv.innerHTML = '<div style="color:#888;text-align:center;margin-top:2rem;">No graph data available.</div>';
				}
			}
		});
		</script>
	</div>
</body>
</html>
